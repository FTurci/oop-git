[
  {
    "objectID": "wp_gitgithub/exercises.html",
    "href": "wp_gitgithub/exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Exercise\n\n\n\nThe following code is written in bash and creates folders named folder1, folder2,…,folder10:\nfor i in {1..10}; do\n    mkdir folder$i\ndone\nNote the close similarity with Python.\nCreate a new file named create_folders.sh using the command touch. Edit the file directly in the shell using either the command nano (easier) or vim (harder) and type the script inside the file.\nThen, run the script via\nbash create_folders.sh\nComplete the following tasks by solely using the shell:\n\nRename folder10 as folder0\nDelete folder folder0\nCreate a file inside folder1 called README.md and type the following text:\n\nThis is a README.md file\nIt contains essential documentation on the project.\n\nChange the working directory name to folder1\nUse the command grep to print out at what line the word essential is contained in the file README.md",
    "crumbs": [
      "Using `git`",
      "Exercises"
    ]
  },
  {
    "objectID": "wp_gitgithub/exercises.html#shell",
    "href": "wp_gitgithub/exercises.html#shell",
    "title": "Exercises",
    "section": "",
    "text": "Exercise\n\n\n\nThe following code is written in bash and creates folders named folder1, folder2,…,folder10:\nfor i in {1..10}; do\n    mkdir folder$i\ndone\nNote the close similarity with Python.\nCreate a new file named create_folders.sh using the command touch. Edit the file directly in the shell using either the command nano (easier) or vim (harder) and type the script inside the file.\nThen, run the script via\nbash create_folders.sh\nComplete the following tasks by solely using the shell:\n\nRename folder10 as folder0\nDelete folder folder0\nCreate a file inside folder1 called README.md and type the following text:\n\nThis is a README.md file\nIt contains essential documentation on the project.\n\nChange the working directory name to folder1\nUse the command grep to print out at what line the word essential is contained in the file README.md",
    "crumbs": [
      "Using `git`",
      "Exercises"
    ]
  },
  {
    "objectID": "wp_gitgithub/exercises.html#gitshell",
    "href": "wp_gitgithub/exercises.html#gitshell",
    "title": "Exercises",
    "section": "2 Git+Shell",
    "text": "2 Git+Shell\n\n\n\n\n\n\nExercises\n\n\n\nAssuming that you have completed the main tasks of this workshop, complete the following additional tasks on your git repository:\n\nUsing git --help to find a way to consult the log of your various commits\nThe shell has an operator called output redirection: it is the symbol &gt;. Use output redirection to write your log to a file named mygit.log\nAdd the mygit.log file to the repository on the main branch and commit the changes.\nCheck the new status of the log: can you find your commit?\nWe now want to go back to a version of the commit prior to the addition fo the log file. Every commit has its own unique id (strings like 455005dc29dc6727de7ee36fee4b49a13b39f73f) called commit hashes. Find the commit hash of the commit that precedes our latest addition. To reset the master to that point use\n\ngit reset --hard &lt;commit-hash&gt;\nIs the mygit.log still there?",
    "crumbs": [
      "Using `git`",
      "Exercises"
    ]
  },
  {
    "objectID": "wp_gitgithub/shell.html",
    "href": "wp_gitgithub/shell.html",
    "title": "Using the shell",
    "section": "",
    "text": "Create a local project directory\nCreate and edit README.md file",
    "crumbs": [
      "Using `git`",
      "Using the shell"
    ]
  },
  {
    "objectID": "wp_gitgithub/shell.html#aims",
    "href": "wp_gitgithub/shell.html#aims",
    "title": "Using the shell",
    "section": "",
    "text": "Create a local project directory\nCreate and edit README.md file",
    "crumbs": [
      "Using `git`",
      "Using the shell"
    ]
  },
  {
    "objectID": "wp_gitgithub/shell.html#learning-outcomes",
    "href": "wp_gitgithub/shell.html#learning-outcomes",
    "title": "Using the shell",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nBuild confidence in navigating the filesystem, creating, deleting and editing files and folders",
    "crumbs": [
      "Using `git`",
      "Using the shell"
    ]
  },
  {
    "objectID": "wp_gitgithub/shell.html#the-shell",
    "href": "wp_gitgithub/shell.html#the-shell",
    "title": "Using the shell",
    "section": "The shell",
    "text": "The shell\nHere we recall very briefly why we use the shell environment and how normal operations are typically performed. These topics have already been covered in the previous term.\nThe shell allows you to interact with a computer without the need of a graphical user interface (GUI). This has three main advantages:\n\nit allows you to operate on files and folders programmatically\nit allows you to interact easily with remote machines, e.g. the High Performance Computing facilities of the University of Bristol\nit allows to have more direct access to low-level operations of your machine (installing and fine-tuning software, libraries and various components)\n\n\n\n\n\n\n\nImportant\n\n\n\nIt is essential to learn how to use the shell properly in order to understand and develop more advanced scientific computing tools.",
    "crumbs": [
      "Using `git`",
      "Using the shell"
    ]
  },
  {
    "objectID": "wp_gitgithub/shell.html#basic-shell-usage",
    "href": "wp_gitgithub/shell.html#basic-shell-usage",
    "title": "Using the shell",
    "section": "Basic shell usage",
    "text": "Basic shell usage\n\nList files and directories: Displays the contents of the current directory.\nls\nChange directory: Moves to a different directory.\ncd /path/to/directory\nCreate a new directory: Creates a new folder.\nmkdir new_folder\nRemove a file: Deletes a specific file.\nrm file.txt\nRemove a directory: Deletes a directory and its contents.\nrm -r directory_name\nMove or rename a file: Moves a file to a new location or renames it.\nmv old_file.txt new_location/\nCopy a file: Copies a file to a new location.\ncp file.txt /path/to/destination/\nCreate a new file: Creates an empty file.\ntouch newfile.txt\nEdit a file: Opens a file in a text editor like nano for editing.\nnano file.txt\nView the contents of a file: Displays the contents of a file in the terminal.\nbash     cat file.txt\nSearch for text in a file: Searches for specific text in a file.\nbash     grep \"search_term\" file.txt\nShow current directory path: Displays the full path of the current working directory.\nbash     pwd\nCopy a directory: Copies a directory and its contents.\nbash     cp -r source_directory/ destination_directory/\nMove back one directory: Moves up one directory level.\nbash     cd ..\nDisplay disk usage: Shows the disk usage of files and directories.\nbash     du -sh *",
    "crumbs": [
      "Using `git`",
      "Using the shell"
    ]
  },
  {
    "objectID": "wp_gitgithub/shell.html#to-dos",
    "href": "wp_gitgithub/shell.html#to-dos",
    "title": "Using the shell",
    "section": "To-dos",
    "text": "To-dos\nNow that we know how to manipulate folder and file, we start our project by creating\n\na dedicated directory\na README.md file to contain the project documentation\n\n\n\n\n\n\n\nTask 1: create the local project directory\n\n\n\nNow that we have overviewed basic shell command, we can set off and create a local directory that will contain our project.\nWe name the project vicsek-cpp.\nmkdir vicsek-cpp\n\n\n\n\n\n\n\n\nTask 2: create the README.md file\n\n\n\nInside the folder, we can use our favourite editor (e.g. vim or nano or VSCode if we like) to create and edit the README.md file.\nInclude a header and a brief description. You will provide more documentation later on.\nFor the root working directory, typing\nls vicsek-cpp\nshould return\nREADME.md",
    "crumbs": [
      "Using `git`",
      "Using the shell"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Engineering and Object Oriented Programming",
    "section": "",
    "text": "Welcome to the Software Engineering and Object Oriented Programming part of the SCIF20002 Programming and Data Analysis for Scientists course.\n\nThis part of the course focuses on developing your software engineering skills and your knowledge of object-oriented programming through the achievement of a practical simulation project. Over the course of five sessions, you will acquire the tools and explore the instruments to:\n\n\n\n\n\n\n\nCreate your own git repository locally and synchronise it on Github\nLearn to track changes, construct commits and collaborate with others\nWrite an object-oriented code in C++ and Python\nWrite Python wrapper code to interface with C++ using pybind\n\n\n\n\n\n\n\n\nYou will need:\n\nconsolidated knowledge of how to interact with a Unix shell\nconsolidated knowledge of Python\nconsolidated knowledge of basic C++ syntax\ninitial knowledge of classes in C++\nknowledge of the C++ compilation process\n\n\n\n\nYou will need access to a complete environment with\n\na Unix shell (e.g. a Terminal)\na C++ compiler (gcc/g++)\nan installation of git\na Python environment\nsuitable editor (e.g. VSCode).\n\nThe Noteable environment accessible from Blackboard provides all of these.\nHowever, you are encouraged to have your own software development environment installed locally on your machines.\nHere are some architecture-dependent recommendations:\n\nWindows 11MacOSLinuxChromeOS\n\n\nShell\nThe recommended way to do software development on Windows is to install the Windows Linux Subsystem (WSL, version 2). This installs a well-integrated local Linux distribution. ↗.\nIn brief, you will need to open the Windows Command Prompt in administrator mode by right-clicking and selecting Run as administrator and then type the single command\nwsl --install\nRestart the machine and then launch WSL.\nC++ compiler\nFrom the WSL shell, install the C/C++ compiler with\nsudo apt install gcc\nYou will be prompted to enter the password that you will have set for your WSL user.\nGit\nThe version control software git is installed with\nsudo apt-get install git\nTo interact with Github, it is recommended to also install the Github command-line utility gh. To do so, first add the official sources (copy and paste command)\n(type -p wget &gt;/dev/null || (sudo apt update && sudo apt-get install wget -y)) \\\n    && sudo mkdir -p -m 755 /etc/apt/keyrings \\\n        && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \\\n        && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg &gt; /dev/null \\\n    && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \\\n    && echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | sudo tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/null \\\n    && sudo apt update \\\n    && sudo apt install gh -y\nThen update the pakcage list and install gh\nsudo apt update\nsudo apt install gh\nPython environment\nA basic working environment in Python is installed from the WSL shell via\nsudo apt install python3 python3-pip ipython3\nYou can then install scientific computing packages via pip\npip install numpy matplotlib scipy\nCode editor\nThe simplest option is to install Visual Studio Code and configure it to work with WSL.\nHere is the offical guidance ↗️\n\n\nShell\nThe Mac already has a proper shell, called Terminal.\nIt is useful however to install a package manager that simplifies the installation of software. The most suitable is homebrew.\nTo install it, open a Terminal and type (you can copy and paste the command below)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nC++\nThe Mac already comes with a good compiler installed called clang, with aliases for commands such as gcc  andg++`.\nYou may want to install a GNU compiler ( the standard gcc compiler that you have, for example, on the bristol High Performance Computing clusters) you can install it with homebrew using:\nbrew install gcc\nThis will install the latest version of gcc, which you will access with the command gcc-xx wher xx is the version number. For example gcc-14.\nGit\nThe Mac should have git pre-installed.\nTo interact with Github, it is recommended to also install the Github command-line utility gh via\nbrew install gh\nPython\nThe Mac already has Python installed as well. You can use it and readily use pip to install the packages that you need using\npip3 install numpy matplotlib scipy\nHowever, a more flexible way to manage different version of Python and Python environments is to install pyenv. More information here ↗️\nCode editor\nYou can install whatever editor you prefer. A simple option is Visual Studio Code, which you can download from this link ↗️\nAtelemetry-free version of VSCode can be installed via homewbrew\nbrew install --cask vscodium\n\n\nDepending on the linux distribution, you may have different package managers to install software. Here we assume a Debian-based distribution such as Ubuntu, where the package manager is apt (or apt-get).\nShell\nAll Linux distributions have an application to launch a shell, often called Terminal.\nC++\nThe C/C++ compilers are normally already installed. If not, just type\nsudo apt-get install gcc\nGit\ngit is normally available. If not, just type\nsudo apt-get install git\nTo interact with Github, it is recommended to also install the Github command-line utility gh. To do so, first add the official sources (copy and paste command)\n(type -p wget &gt;/dev/null || (sudo apt update && sudo apt-get install wget -y)) \\\n    && sudo mkdir -p -m 755 /etc/apt/keyrings \\\n        && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \\\n        && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg &gt; /dev/null \\\n    && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \\\n    && echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | sudo tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/null \\\n    && sudo apt update \\\n    && sudo apt install gh -y\nThen update the pakcage list and install gh\nsudo apt update\nsudo apt install gh\nPython\nYou install Python via\nsudo apt-get install python3 python3-pip ipython3\nYou can then install scientific computing packages via pip\npip install numpy matplotlib scipy\nCode editor\nYou can install whatever editor you prefer, including VSCode ↗️.\nOn Ubuntu, a telemetry-free version of VSCode can be installed via snaps\nsnap install codium --classic\n\n\nChromebooks have a Linux operating system running under the hood.\nIt is possible to access it by activating the Linux development environment, see the documentation ↗️\nYou can then follow the same instructions as Linux users.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#requirements",
    "href": "index.html#requirements",
    "title": "Software Engineering and Object Oriented Programming",
    "section": "",
    "text": "You will need:\n\nconsolidated knowledge of how to interact with a Unix shell\nconsolidated knowledge of Python\nconsolidated knowledge of basic C++ syntax\ninitial knowledge of classes in C++\nknowledge of the C++ compilation process\n\n\n\n\nYou will need access to a complete environment with\n\na Unix shell (e.g. a Terminal)\na C++ compiler (gcc/g++)\nan installation of git\na Python environment\nsuitable editor (e.g. VSCode).\n\nThe Noteable environment accessible from Blackboard provides all of these.\nHowever, you are encouraged to have your own software development environment installed locally on your machines.\nHere are some architecture-dependent recommendations:\n\nWindows 11MacOSLinuxChromeOS\n\n\nShell\nThe recommended way to do software development on Windows is to install the Windows Linux Subsystem (WSL, version 2). This installs a well-integrated local Linux distribution. ↗.\nIn brief, you will need to open the Windows Command Prompt in administrator mode by right-clicking and selecting Run as administrator and then type the single command\nwsl --install\nRestart the machine and then launch WSL.\nC++ compiler\nFrom the WSL shell, install the C/C++ compiler with\nsudo apt install gcc\nYou will be prompted to enter the password that you will have set for your WSL user.\nGit\nThe version control software git is installed with\nsudo apt-get install git\nTo interact with Github, it is recommended to also install the Github command-line utility gh. To do so, first add the official sources (copy and paste command)\n(type -p wget &gt;/dev/null || (sudo apt update && sudo apt-get install wget -y)) \\\n    && sudo mkdir -p -m 755 /etc/apt/keyrings \\\n        && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \\\n        && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg &gt; /dev/null \\\n    && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \\\n    && echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | sudo tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/null \\\n    && sudo apt update \\\n    && sudo apt install gh -y\nThen update the pakcage list and install gh\nsudo apt update\nsudo apt install gh\nPython environment\nA basic working environment in Python is installed from the WSL shell via\nsudo apt install python3 python3-pip ipython3\nYou can then install scientific computing packages via pip\npip install numpy matplotlib scipy\nCode editor\nThe simplest option is to install Visual Studio Code and configure it to work with WSL.\nHere is the offical guidance ↗️\n\n\nShell\nThe Mac already has a proper shell, called Terminal.\nIt is useful however to install a package manager that simplifies the installation of software. The most suitable is homebrew.\nTo install it, open a Terminal and type (you can copy and paste the command below)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nC++\nThe Mac already comes with a good compiler installed called clang, with aliases for commands such as gcc  andg++`.\nYou may want to install a GNU compiler ( the standard gcc compiler that you have, for example, on the bristol High Performance Computing clusters) you can install it with homebrew using:\nbrew install gcc\nThis will install the latest version of gcc, which you will access with the command gcc-xx wher xx is the version number. For example gcc-14.\nGit\nThe Mac should have git pre-installed.\nTo interact with Github, it is recommended to also install the Github command-line utility gh via\nbrew install gh\nPython\nThe Mac already has Python installed as well. You can use it and readily use pip to install the packages that you need using\npip3 install numpy matplotlib scipy\nHowever, a more flexible way to manage different version of Python and Python environments is to install pyenv. More information here ↗️\nCode editor\nYou can install whatever editor you prefer. A simple option is Visual Studio Code, which you can download from this link ↗️\nAtelemetry-free version of VSCode can be installed via homewbrew\nbrew install --cask vscodium\n\n\nDepending on the linux distribution, you may have different package managers to install software. Here we assume a Debian-based distribution such as Ubuntu, where the package manager is apt (or apt-get).\nShell\nAll Linux distributions have an application to launch a shell, often called Terminal.\nC++\nThe C/C++ compilers are normally already installed. If not, just type\nsudo apt-get install gcc\nGit\ngit is normally available. If not, just type\nsudo apt-get install git\nTo interact with Github, it is recommended to also install the Github command-line utility gh. To do so, first add the official sources (copy and paste command)\n(type -p wget &gt;/dev/null || (sudo apt update && sudo apt-get install wget -y)) \\\n    && sudo mkdir -p -m 755 /etc/apt/keyrings \\\n        && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \\\n        && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg &gt; /dev/null \\\n    && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \\\n    && echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | sudo tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/null \\\n    && sudo apt update \\\n    && sudo apt install gh -y\nThen update the pakcage list and install gh\nsudo apt update\nsudo apt install gh\nPython\nYou install Python via\nsudo apt-get install python3 python3-pip ipython3\nYou can then install scientific computing packages via pip\npip install numpy matplotlib scipy\nCode editor\nYou can install whatever editor you prefer, including VSCode ↗️.\nOn Ubuntu, a telemetry-free version of VSCode can be installed via snaps\nsnap install codium --classic\n\n\nChromebooks have a Linux operating system running under the hood.\nIt is possible to access it by activating the Linux development environment, see the documentation ↗️\nYou can then follow the same instructions as Linux users.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "wp_oop/oop-slides.html#aims",
    "href": "wp_oop/oop-slides.html#aims",
    "title": "Hands on objects and classes",
    "section": "Aims",
    "text": "Aims\n\nDefine the essential properties of our simulation and identify them as objects\nDesign the basic relationships between such objects\nConstruct the skeleton of the simulation by creating bare bone classes for the main objects"
  },
  {
    "objectID": "wp_oop/oop-slides.html#learning-outcomes",
    "href": "wp_oop/oop-slides.html#learning-outcomes",
    "title": "Hands on objects and classes",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nFamiliarise with the rules of Vicsek flocking model\nPractice object-oriented design choices in C++"
  },
  {
    "objectID": "wp_oop/oop-slides.html#object-oriented-programming-is-about-actions-between-objects",
    "href": "wp_oop/oop-slides.html#object-oriented-programming-is-about-actions-between-objects",
    "title": "Hands on objects and classes",
    "section": "Object-oriented programming is about actions between objects",
    "text": "Object-oriented programming is about actions between objects\nA lot of your programming up to now has been data-centric: you received data, often simply tabulated numerical data, and then you have manipulated it using suitable functions, occasionally custom designed. In this sense, programming boils down to retrieving data, processing it with suitable functions, and produce new data (to be eventually processed again). This procedural programming is very linear, but is often very problem specific: your program finally consists of a well defined pipeline of steps where the data get progressively manipulated. The code becomes easily quite long and complicated."
  },
  {
    "objectID": "wp_oop/oop-slides.html#modelling-flocking-using-the-vicsek-model",
    "href": "wp_oop/oop-slides.html#modelling-flocking-using-the-vicsek-model",
    "title": "Hands on objects and classes",
    "section": "Modelling flocking using the Vicsek model",
    "text": "Modelling flocking using the Vicsek model\nIn this mini-project, we are using a minimal model of flocking as our simple application of object-oriented programming to scientific computing.\nWew use the Vicsek model, a celebrated model to describe the behaviour of self-propelled agents subject to alignment interactions.\nThe problem is two-dimensional. It simulates the collective behavior of self-propelled particles that align their velocities with their neighbors within a certain radius. Each particle moves in a random direction and adjusts its orientation to match the average direction of nearby particles, leading to the emergence of coordinated motion or flocking."
  },
  {
    "objectID": "wp_oop/oop.html",
    "href": "wp_oop/oop.html",
    "title": "Hands on objects and classes",
    "section": "",
    "text": "Define the essential properties of our simulation and identify them as objects\nDesign the basic relationships between such objects\nConstruct the skeleton of the simulation by creating bare bone classes for the main objects",
    "crumbs": [
      "Object-Oriented thinking",
      "Hands on objects and classes"
    ]
  },
  {
    "objectID": "wp_oop/oop.html#aims",
    "href": "wp_oop/oop.html#aims",
    "title": "Hands on objects and classes",
    "section": "",
    "text": "Define the essential properties of our simulation and identify them as objects\nDesign the basic relationships between such objects\nConstruct the skeleton of the simulation by creating bare bone classes for the main objects",
    "crumbs": [
      "Object-Oriented thinking",
      "Hands on objects and classes"
    ]
  },
  {
    "objectID": "wp_oop/oop.html#learning-outcomes",
    "href": "wp_oop/oop.html#learning-outcomes",
    "title": "Hands on objects and classes",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nFamiliarise with the rules of Vicsek flocking model\nPractice object-oriented design choices in C++",
    "crumbs": [
      "Object-Oriented thinking",
      "Hands on objects and classes"
    ]
  },
  {
    "objectID": "wp_oop/oop.html#object-oriented-programming-is-about-actions-between-objects",
    "href": "wp_oop/oop.html#object-oriented-programming-is-about-actions-between-objects",
    "title": "Hands on objects and classes",
    "section": "Object-oriented programming is about actions between objects",
    "text": "Object-oriented programming is about actions between objects\nA lot of your programming up to now has been data-centric: you received data, often simply tabulated numerical data, and then you have manipulated it using suitable functions, occasionally custom designed. In this sense, programming boils down to retrieving data, processing it with suitable functions, and produce new data (to be eventually processed again). This procedural programming is very linear, but is often very problem specific: your program finally consists of a well defined pipeline of steps where the data get progressively manipulated. The code becomes easily quite long and complicated.\n\nObject-oriented programming is different: the idea is to look at the problem that you want to seolve and identify intelligent ways to break it down into smaller problems, possibly quite generic. In particular, the goal is to group variables and functions together into new data types that therefore enjoy new properties and relationships. This allows you to break down a complex code into simpler, smaller parts.\nFrom this description it is clear that object-oriented programming (OOP) will be:\n\nunsuitable for small projects that can be addressed with standard or existing data types\nvery suitable when considering new problems, with many different parts interacting in various different ways\n\nTo make object-oriented interesting, here we are considering an explicit example where reasoning in terms of objects helps us design our code.",
    "crumbs": [
      "Object-Oriented thinking",
      "Hands on objects and classes"
    ]
  },
  {
    "objectID": "wp_oop/oop.html#modelling-flocking-using-the-vicsek-model",
    "href": "wp_oop/oop.html#modelling-flocking-using-the-vicsek-model",
    "title": "Hands on objects and classes",
    "section": "Modelling flocking using the Vicsek model",
    "text": "Modelling flocking using the Vicsek model\nIn this mini-project, we are using a minimal model of flocking as our simple application of object-oriented programming to scientific computing.\nWew use the Vicsek model, a celebrated model to describe the behaviour of self-propelled agents subject to alignment interactions.\nThe problem is two-dimensional. It simulates the collective behavior of self-propelled particles that align their velocities with their neighbors within a certain radius. Each particle moves in a random direction and adjusts its orientation to match the average direction of nearby particles, leading to the emergence of coordinated motion or flocking.\n\n\n\n\n\n\n\nAlgorithm\n\n\n\nThe 2D Vicsek model algorithm can be described in these steps:\n\nInitialize: Place \\(N\\) particles at random positions \\(\\mathbf{r}_i\\) with random velocities \\(\\mathbf{v}_i = v (\\cos\\theta_i, \\sin\\theta_i)\\), where \\(\\theta_i\\) is the orientation angle.\nNeighbor Identification: For each particle \\(i\\), identify neighbors within radius \\(r\\).\nAlignment: Compute the average direction of neighbors, including \\(i\\): \\[\n\\bar{\\theta}_i = \\text{atan2}\\left(\\sum_{\\rm j \\in neighbours} \\sin\\theta_j, \\sum_{\\rm j \\in neighbours} \\cos\\theta_j\\right)\n\\]\nNoise: Add a random perturbation \\(u\\) to the orientation as a random variable uniformly distributed in the interval \\([-\\eta/2,\\eta/2]\\), where \\(\\eta\\) is teh noise strength\n\\[\n\\theta_i^{\\text{new}} = \\bar{\\theta}_i + u\n\\]\nUpdate Position: Move each particle with its updated velocity: \\[\n\\mathbf{r}_i^{\\text{new}} = \\mathbf{r}_i + \\mathbf{v}_i \\Delta t\n\\]\nRepeat: Iterate for the desired number of time steps.\n\n\n\n\n\nFrom the algorithm above we can extract a few key conceptual entities needed for our simulation\n\n\n\n\n\nclassDiagram\n direction LR\n    class System{\n      particle_number\n      noise_strength\n      list~Particle~ particles\n      update_rule()\n  \n    }\n\n    class Box {\n        size\n        boundary_conditions\n    }\n\n    class Particle {\n        position\n        orientation\n    }\n  System --&gt; Box : contains\n  System \"1\" --&gt; \"N\" Particle : contains",
    "crumbs": [
      "Object-Oriented thinking",
      "Hands on objects and classes"
    ]
  },
  {
    "objectID": "model.html",
    "href": "model.html",
    "title": "The Vicsek model",
    "section": "",
    "text": "The Vicsek model"
  },
  {
    "objectID": "plan.html",
    "href": "plan.html",
    "title": "Plan",
    "section": "",
    "text": "In this part of the course, we set ourselves a very specific goal:\n\n\n\n\n\n\nGoal\n\n\n\nWe want to realise a Github repository containing a C++ project with Python frontend to simulate a simple particle-based simulation.\n\n\nWe will have five sessions to reach this target. We will proceed in steps:\n\n\n\n\n\n\n\nDate\nTopic\n\n\n\n\nWeek 13 - 13/01/2025\nLearn how to use git to perform version control and interact with Github\n\n\nWeek 14 - 20/01/2025\nRecall the notion of Object-Oriented programming (OOP) and design the (OOP) structure of our simulation.\n\n\nWeek 15 - 27/01/2025\nImplement the essential OOP structure of your simulator in C++ and with minimal Python visualisation tools\n\n\nWeek 16 - 03/03/2025\nIntroduce pybind11 to interface the C++ code with Python\n\n\nWeek 17 - 10/02/2025\nWrapping in Python and improvements to the code\n\n\n\nThis journey will allow you to build your coding skills in C++, connect them to your Python knowledge and apply them to a realistic modelling problem.\n\n\nThe final product of the simulation is a visualisation of the Vicsek model, an elementary model to represent the flocking behaviour of birds, fish and various other agents. An example animation is here below.\n\n\n\nAnimation of the Vicsek model\n\n\nYou will learn about the the specifics the model in the Vicsek model section.\n\n\n\nDuring the project you will acquire a number of skills, primarily in two areas:\n\n\n\n\n\n\n\nSoftware engineering (e.g. version control with git)\nObject-oriented programming (in C++ and Python)\n\n\n\n\nThe Test 2 assessment in Week 17 will probe your understanding of both via a dedicated and self-contained exercise. This means that the final product mentioned is not assessed. It is, however, a constitutive part of your learning trajectory.",
    "crumbs": [
      "Plan"
    ]
  },
  {
    "objectID": "plan.html#final-product",
    "href": "plan.html#final-product",
    "title": "Plan",
    "section": "",
    "text": "The final product of the simulation is a visualisation of the Vicsek model, an elementary model to represent the flocking behaviour of birds, fish and various other agents. An example animation is here below.\n\n\n\nAnimation of the Vicsek model\n\n\nYou will learn about the the specifics the model in the Vicsek model section.",
    "crumbs": [
      "Plan"
    ]
  },
  {
    "objectID": "plan.html#assessment",
    "href": "plan.html#assessment",
    "title": "Plan",
    "section": "",
    "text": "During the project you will acquire a number of skills, primarily in two areas:\n\n\n\n\n\n\n\nSoftware engineering (e.g. version control with git)\nObject-oriented programming (in C++ and Python)\n\n\n\n\nThe Test 2 assessment in Week 17 will probe your understanding of both via a dedicated and self-contained exercise. This means that the final product mentioned is not assessed. It is, however, a constitutive part of your learning trajectory.",
    "crumbs": [
      "Plan"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html",
    "href": "wp_gitgithub/git.html",
    "title": "Version control with git",
    "section": "",
    "text": "Initialise a local git repository\nAdd files to track\nCommit some changes",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html#aims",
    "href": "wp_gitgithub/git.html#aims",
    "title": "Version control with git",
    "section": "",
    "text": "Initialise a local git repository\nAdd files to track\nCommit some changes",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html#learning-outcomes",
    "href": "wp_gitgithub/git.html#learning-outcomes",
    "title": "Version control with git",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nUnderstand the general principles of version control\nMastery of how git implements the main features of version control",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html#general-ideas-about-version-control",
    "href": "wp_gitgithub/git.html#general-ideas-about-version-control",
    "title": "Version control with git",
    "section": "General ideas about version control",
    "text": "General ideas about version control\nVersion control is an approach to coding that allows you to keep track of the code evolution.\nYou may think of coding as a linear process, where a first version is followed by another more advanced version, which is again followed by a successive more refined version and so on.\n\n\n\n\n\nflowchart LR\n    A[Version 1] --&gt;  B[Version 2] --&gt; C[Version 3]--&gt; D[...]\n\n\n\n\n\n\nThis is not at all the case. In fact, as we develop our code we tyically try various ideas, similarly to what you would do if you were writing a novel, perform an experiment, or explore an uncharted territory.\n\n\n\n\n\nflowchart LR\n    A[Version 1] --&gt; B\n    B[Version 2] --&gt; C[Version 3]--&gt; D[...]\n    A--&gt;Aa[Variant 1.a]--&gt;B\n    A--&gt;Ab[Variant 1.b]--&gt;E[Alternative version 2]--&gt;C\n\n\n\n\n\n\n\n\nThis is even more evident when collaboration is at play: different developers will try different approaches and require a system to keep track of their respective modifications and that helps them with bringing them together into a unified project. In fact, regularly, the various ideas need to come together and merge for the project to keep its unitary structure.\nVersion control tools serve precisely this purpose, and git is the most popular of such tools.\nIt is powerful, but its usage can be subtle at times, as illustrated by the following cartoon:\n\n\n\nGit according to the celebrated comic strip xkcd\n\n\nVersion control therefore solves two problems:\n\nkeeping track of the code changes performed by a single performs\nallow to harmonise and synchronise the code changes of various collaborators\n\nWe are going to focus mostly on the first part, but it is important to realise that git is an essential tool for code development in large projects.",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html#terminology",
    "href": "wp_gitgithub/git.html#terminology",
    "title": "Version control with git",
    "section": "Terminology",
    "text": "Terminology\n\nRepositories\nVersion control use repositories. These are a database of code versions, stored in an efficient manner, focusing on the changes between a version and another.\n\n\nClones\nEach user of the repository has their own working copy of all the files (any kinds of files) of the project. This clone of the repository is typically stored on the local machine.\nChanges to the local clone are not reflected in the repository unless the users explicitely require this to be the case.\n\n\nDistributed version control\nIn distribute version control each user has a complete copy of the repository, and they can perform their changes independently from other users, work locally and offline and eventually do collaborative work by merging their own versions with the one of others.\nIn principle, this can be done without a central server (e.g. peer to peer). In practice, one often uses some form of online repository, e.g. Github, Gitlab etc.\n\n\nBranch\nBranching in git allow you to explore various ideas in parallel, developing in different directions and experimenting new features. Branching is a backbone ides in git.\nA repository typically has a main branch where the functional code is stored. When we want to develop our code we create new feature branches\n\n\n\n\n\n    %%{init: { 'logLevel': 'debug', 'theme': 'default' , 'themeVariables': {\n              'git0': '#ff0000',\n              'git1': '#00ff00',\n              'git2': '#0000ff',\n              'git3': '#ff00ff',\n              'git4': '#00ffff',\n              'git5': '#ffff00',\n              'git6': '#ff00ff',\n              'git7': '#00ffff'\n       } } }%%\ngitGraph\n   commit id: \"main\"\n   branch feature\n   commit id: \"main work\"\n   checkout feature\n   commit id: \"feature work\"\n   checkout main\n   commit id: \"more main work\"\n   merge feature\n\n\n\n\n\n\nOn every branch, we can store out individual advancements as commits (see below). Eventually, when we are happy for our feature to be integrated with the main branche, we merge the feature branch with the main branch.\n\n\nCommits\nWhen you want a change to be registered in the repository’s database, your commit your changes to the repository. This means that a new entry in the database is added, keeping track of a timestamp associated with your changes and (often) an explanatory description of what the modification entails.\n\n\nPushing [with the remote respotiory only]\nIf you also have a remote repository (e.g. on GitHub), you can synchronise the changes between the local branch and the remote branch via the push operation.\n\n\nFetching [with the remote respotiory only]\nFetch allows you to retrieve the changes from a remote repository, see them and decide whether to merge such changes with your local repository (or not).\n\n\nPulling [with the remote respotiory only]\nPulling is simply fetching, followed by automatic merging.\n\n\nBundling\nAn efficient way to produce a package out of a git repository is to construct a bundle. This is a single file that contains a collection of commits, branches and logs allowing you to transfer or store the repository’s content without requiring access to a remote server.\n\n\nScheme\n\n\n\nHow git works, adapted from https://homes.cs.washington.edu/~mernst/advice/version-control.html ↗️",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html#hands-on-approach-to-git",
    "href": "wp_gitgithub/git.html#hands-on-approach-to-git",
    "title": "Version control with git",
    "section": "Hands-on approach to git",
    "text": "Hands-on approach to git\nWe start off working locally and creating a local project.",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git.html#to-dos",
    "href": "wp_gitgithub/git.html#to-dos",
    "title": "Version control with git",
    "section": "To-dos",
    "text": "To-dos\nPreviously, you should have created a project folder with a README.md file. We now want to setup our local git repository.\n\n\n\n\n\n\n\n\nTask 1: initialise the repository\n\n\n\nGo to the project folder vicsek-cpp and initialise the git repository.\nUse the information above or git --help to find the correct command to use.\n\n\n\n\n\n\n\n\n\n\n\nTask 2: create a .gitignore file and add it to the staging area\n\n\n\nWe want to tell git not to keep track of specifc files. For, example we want to ignore hidden files that are specific to MacOS. A hidden file/folder haas a name that starts with . .\nTo provide git with a list of files to ignore, we create a (hidden) configuration file inside vicsek-cpp called .gitignore.\nCreate such file and enter the following string\n.DS_Store\nThen add the .gitignore file to the staging area.\nCheck git status to see if your .gitignore is ready to be committed and then commit it with a suitable comment.\n\n\n\n\n\n\n\n\n\n\n\nTask 3: ignoring files and directly committing the changes\n\n\n\nSuppose now that we also want to ignore all files that end with .txt. The .gitignore file accepts the wildcard *.\nModify the .gitignore to ignore all .txt files. With a suitable option to the git commit command, stage and commit the changes in a single go.\nThen create two new files: - a notes.txt file - a notes.md file\nAdd all new files in the current folder with git add ., commit your changes to the repository and then check the files added to the repository with git ls-files.\nIs notes.txt in your list?\n\n\n\n\n\n\n\n\n\n\n\nTask 4: branching\n\n\n\nWe want to now start developing our code. For this purpose, we create a new branch called develop. To do so we use the command\ngit branch develop\nTo check which branches now exist in your repository just type\ngit branch\nA * should appear on the brenach you are on (which should be main). To switch to the develop branch use\ngit checkout develop\nCheck that you are on the right branch now (see above).\nOnce you are on your develop branch, create a new folder src where we will put the C++ code (do not remember how to create a folder? go back to Using the shell).\nInside src, create our C++ main file main.cpp, e.g. using a suitable editor (e.g. nano , pico or vim).\nThe minimal content should be the following\n#include &lt;iostream&gt;\n\nint main(){\n    return 0\n}\nNow, add the src folder with its content to the git repository and commit the changes.\nSwitch back to the main branch: what happened to the src folder?\n\n\n\n\n\n\n\n\n\n\n\nTask 4: merging\n\n\n\nNow that you have your develop branch set up, attempt to merge it back with the main branch using the git merge command. If you are not sure about how to use it, check the documentation with git merge --help.\n\n\n\n\n\n\n\n\n\n\n\nTask 5: bundling\n\n\n\nUse now the command\ngit bundle create myrepo.bundle --all\nto create a single bundle file conatining all of the repository. Move it to another folder (or even another machine with git, e.g. your Noteable account) and unpack it with\ngit clone myrepo.bundle\nCna you check the branch structure? and the status?",
    "crumbs": [
      "Using `git`",
      "Version control with `git`"
    ]
  },
  {
    "objectID": "wp_gitgithub/git-slides.html#aims",
    "href": "wp_gitgithub/git-slides.html#aims",
    "title": "Version control with git",
    "section": "Aims",
    "text": "Aims\n\nInitialise a local git repository\nAdd files to track\nCommit some changes"
  },
  {
    "objectID": "wp_gitgithub/git-slides.html#learning-outcomes",
    "href": "wp_gitgithub/git-slides.html#learning-outcomes",
    "title": "Version control with git",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nUnderstand the general principles of version control\nMastery of how git implements the main features of version control"
  },
  {
    "objectID": "wp_gitgithub/git-slides.html#general-ideas-about-version-control",
    "href": "wp_gitgithub/git-slides.html#general-ideas-about-version-control",
    "title": "Version control with git",
    "section": "General ideas about version control",
    "text": "General ideas about version control\nVersion control is an approach to coding that allows you to keep track of the code evolution.\nYou may think of coding as a linear process, where a first version is followed by another more advanced version, which is again followed by a successive more refined version and so on.\n\n\n\n\n\nflowchart LR\n    A[Version 1] --&gt;  B[Version 2] --&gt; C[Version 3]--&gt; D[...]\n\n\n\n\n\n\nThis is not at all the case. In fact, as we develop our code we tyically try various ideas, similarly to what you would do if you were writing a novel, perform an experiment, or explore an uncharted territory.\n\n\n\n\n\nflowchart LR\n    A[Version 1] --&gt; B\n    B[Version 2] --&gt; C[Version 3]--&gt; D[...]\n    A--&gt;Aa[Variant 1.a]--&gt;B\n    A--&gt;Ab[Variant 1.b]--&gt;E[Alternative version 2]--&gt;C"
  },
  {
    "objectID": "wp_gitgithub/git-slides.html#terminology",
    "href": "wp_gitgithub/git-slides.html#terminology",
    "title": "Version control with git",
    "section": "Terminology",
    "text": "Terminology"
  },
  {
    "objectID": "wp_gitgithub/git-slides.html#hands-on-approach-to-git",
    "href": "wp_gitgithub/git-slides.html#hands-on-approach-to-git",
    "title": "Version control with git",
    "section": "Hands-on approach to git",
    "text": "Hands-on approach to git\nWe start off working locally and creating a local project."
  },
  {
    "objectID": "wp_gitgithub/git-slides.html#to-dos",
    "href": "wp_gitgithub/git-slides.html#to-dos",
    "title": "Version control with git",
    "section": "To-dos",
    "text": "To-dos\nPreviously, you should have created a project folder with a README.md file. We now want to setup our local git repository."
  }
]